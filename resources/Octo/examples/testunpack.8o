###########################################
#
#  Unpacking Tests
#
#  Uses the :unpack operative to perform
#  self-modification and rewrite an
#  i := NNN instruction.
#
###########################################

: font
	0x20 0x20 0x20 0x00 0x20 0xF0 0x10 0x70 0x00 0x40 0xE0 0x90 0xE0 0x90 0x90 0x90 
	0xE0 0x90 0xE0 0x90 0xE0 0x80 0x80 0xD0 0xB0 0xB0 0x90 0x90 0x90 0x90 0x60 0x60 
	0x90 0x90 0x90 0x60 0x90 0xD0 0xB0 0x90 0x90 0x90 0x50 0x20 0x40 0x00 0x00 0x00 
	0x00 0x00 0x60 0x90 0xF0 0x90 0x90 0xF0 0x90 0x90 0xF0 0x80 0xE0 0x80 0x80 0x80 
	0x80 0xF0 0x80 0xE0 0x80 0xF0 0x40 0x40 0x40 0xF0 0x20 0x40 0x80 0xF0 0x20 0x20 
	0x20 0xC0 0x60 0x90 0x80 0x90 0x60 0x90 0x90 0xB0 0x70 0x80 0xB0 0x90 0x70 0x80 
	0x60 0x10 0xE0 0x90 0xA0 0xC0 0xA0 0x90 0x90 0xB0 0xB0 0xD0 0xF0 0x40 0x40 0x40 
	0x40 0x90 0x90 0x70 0x10 0xE0

# draw and linewrap a string at an address given
# in the v0-v1 registers. The string will consist
# of a sequence of offsets into the font data:

: display-string
	i := string-addr
	save v1
	v1 := 2 # character x
	v2 := 1 # character y
	v3 := 0 # byte index
	# v4 contains string length
	loop
		: string-addr 0 0
		i += v3
		load v0
		i := font
		i += v0
		sprite v1 v2 5
		v1 += 5
		if v1 == 62 then v2 += 6
		if v1 == 62 then v1 := 2
		v3 += 1
		if v3 != v4 then
	again
;

: demo-string
	0x71 0x1F 0x1A 0x2D 0x35 0x41 0x32 0x0A 0x2D 0x2D 0x2D 0x2D 0x32 0x2D 0x0A 0x1A 
	0x17 0x10 0x3D 0x41 0x2D 0x45 0x24 0x2D 0x6C 0x35 0x41 0x2D 0x0C 0x45 0x5E 0x6C 
	0x32 0x24 0x52 0x41
:const demo-string-length 36

# these constants demonstrate all the valid opcodes
# which can be built with the high nybble in :unpack
:const JUMP  0x1 # jump <label>
:const CALL  0x2 # <label>
:const INDEX 0xA # i := <label>
:const JUMP0 0xB # jump0 <label>

# these aliases are defaults but can be overridden
# to unpack into alternate registers
:alias unpack-hi v0
:alias unpack-lo v1

: main
	:unpack INDEX demo-string
	v4 := demo-string-length
	display-string
	loop again
